/**
 * Content Sanitization Utilities
 *
 * Provides XSS protection for user-generated content, particularly markdown/HTML.
 * Uses DOMPurify to sanitize content while preserving safe formatting.
 *
 * Why this matters:
 * - User-generated patient records can contain malicious scripts
 * - LLM-generated care plans are rendered as markdown (HTML)
 * - Defense-in-depth: sanitize at input AND output
 * - Prevents XSS attacks while maintaining rich text formatting
 *
 * Security approach:
 * 1. Allowlist approach (only permit safe tags)
 * 2. Strip all scripts, event handlers, and dangerous attributes
 * 3. Sanitize both at validation layer AND display layer
 * 4. Use isomorphic-dompurify for SSR compatibility
 */

import DOMPurify from 'isomorphic-dompurify';

/**
 * Sanitize markdown content to prevent XSS attacks
 *
 * Allows common markdown-safe HTML tags while stripping:
 * - <script> tags
 * - Event handlers (onclick, onerror, etc.)
 * - Dangerous protocols (javascript:, data:)
 * - Inline styles (can contain expressions)
 * - iframes, objects, embeds
 *
 * @param content - Raw user input or LLM output
 * @returns Sanitized content safe for rendering
 *
 * @example
 * // Safe markdown
 * sanitizeMarkdown('# Hello\n**Bold** text')
 * // Returns: '# Hello\n**Bold** text'
 *
 * // Malicious input
 * sanitizeMarkdown('<script>alert("XSS")</script>')
 * // Returns: '' (script stripped)
 *
 * // Mixed content
 * sanitizeMarkdown('Safe text <img src=x onerror="alert(1)">')
 * // Returns: 'Safe text ' (dangerous img removed)
 */
export function sanitizeMarkdown(content: string): string {
  return DOMPurify.sanitize(content, {
    // Allowlist of safe HTML tags (generated by markdown)
    ALLOWED_TAGS: [
      // Headings
      'h1',
      'h2',
      'h3',
      'h4',
      'h5',
      'h6',
      // Text formatting
      'p',
      'br',
      'strong',
      'em',
      'u',
      'del',
      's',
      'code',
      'pre',
      // Lists
      'ul',
      'ol',
      'li',
      // Quotes and blocks
      'blockquote',
      'hr',
      // Links (with restrictions below)
      'a',
      // Tables
      'table',
      'thead',
      'tbody',
      'tr',
      'th',
      'td',
      // Inline elements
      'span',
      'div',
    ],

    // Allowlist of safe attributes
    ALLOWED_ATTR: [
      'href', // For links (protocol restricted below)
      'target', // For opening links
      'rel', // For link relationships (noopener, noreferrer)
      'class', // For styling (safe if CSS is controlled)
    ],

    // Allow only safe URL protocols
    ALLOWED_URI_REGEXP: /^(?:(?:(?:f|ht)tps?|mailto|tel):)/i,

    // Disable data attributes (can be used for attacks)
    ALLOW_DATA_ATTR: false,

    // Return empty string for completely malicious content
    RETURN_DOM: false,
    RETURN_DOM_FRAGMENT: false,

    // Add target="_blank" and rel="noopener noreferrer" to all links
    ADD_ATTR: ['target'],
    ADD_TAGS: [],

    // Force target="_blank" for external links (security)
    SAFE_FOR_TEMPLATES: true,
  });
}

/**
 * Sanitize plain text (strips all HTML)
 *
 * Use for fields that should never contain markup:
 * - Patient names
 * - MRNs
 * - Medication names
 *
 * @param content - User input
 * @returns Text with all HTML stripped
 *
 * @example
 * sanitizePlainText('John <script>alert(1)</script> Smith')
 * // Returns: 'John Smith'
 */
export function sanitizePlainText(content: string): string {
  return DOMPurify.sanitize(content, {
    ALLOWED_TAGS: [], // No HTML tags allowed
    ALLOWED_ATTR: [],
    KEEP_CONTENT: true, // Keep text content, just strip tags
  });
}

/**
 * Validate that content doesn't contain dangerous patterns
 *
 * Additional validation layer before sanitization.
 * Useful for logging/alerting on attack attempts.
 *
 * @param content - Content to check
 * @returns Object with validation result and detected threats
 */
export function validateContentSecurity(content: string): {
  safe: boolean;
  threats: string[];
} {
  const threats: string[] = [];

  // Check for common XSS patterns
  const dangerousPatterns = [
    { pattern: /<script/i, threat: 'script tag' },
    { pattern: /javascript:/i, threat: 'javascript: protocol' },
    { pattern: /on\w+\s*=/i, threat: 'event handler' },
    { pattern: /<iframe/i, threat: 'iframe tag' },
    { pattern: /<object/i, threat: 'object tag' },
    { pattern: /<embed/i, threat: 'embed tag' },
    { pattern: /eval\(/i, threat: 'eval() call' },
    { pattern: /expression\(/i, threat: 'CSS expression' },
  ];

  for (const { pattern, threat } of dangerousPatterns) {
    if (pattern.test(content)) {
      threats.push(threat);
    }
  }

  return {
    safe: threats.length === 0,
    threats,
  };
}
