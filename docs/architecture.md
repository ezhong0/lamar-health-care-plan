# System Architecture

## Overview

This application demonstrates a production-ready specialty pharmacy management system built with modern best practices. The architecture emphasizes **type safety**, **domain-driven design**, and **separation of concerns** to create a maintainable, scalable codebase.

## Architectural Principles

### 1. Layered Architecture with Clear Boundaries

The system follows a strict layered architecture that enforces separation of concerns:

```
┌─────────────────────────────────────┐
│   Presentation Layer (React/Next.js)│  ← User interface, forms, displays
├─────────────────────────────────────┤
│   API Layer (Next.js Route Handlers)│  ← HTTP interface, request/response
├─────────────────────────────────────┤
│   Service Layer                     │  ← Business logic orchestration
├─────────────────────────────────────┤
│   Domain Layer                      │  ← Core business rules, entities
├─────────────────────────────────────┤
│   Infrastructure Layer              │  ← Database, external services
└─────────────────────────────────────┘
```

**Why this matters:** Each layer has a single responsibility, making the codebase easier to test, maintain, and extend. Changes in one layer rarely ripple through to others.

### 2. Result Type Pattern for Error Handling

Rather than throwing exceptions or relying on try-catch blocks everywhere, the system uses a **Result monad** pattern:

```typescript
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };
```

**Benefits:**
- **Explicit error handling:** Every function that can fail makes this obvious in its return type
- **Type-safe errors:** Discriminated unions ensure TypeScript catches unhandled error cases
- **Composable:** Results can be chained and transformed without nested try-catch blocks
- **Railway-oriented programming:** Success and failure paths are clearly separated

### 3. Dependency Injection for Testability

Services receive their dependencies through constructor injection rather than importing them directly:

```typescript
class PatientService {
  constructor(
    private db: PrismaClient,
    private duplicateDetector: DuplicateDetectorService,
    private validator: ValidationService
  ) {}
}
```

**Why this matters:** Tests can inject mocks without complex module mocking. The system remains flexible to swap implementations (e.g., different database, different AI provider).

### 4. Branded Types for Compile-Time Safety

The system uses TypeScript's branded types to prevent ID confusion at compile time:

```typescript
type PatientId = string & { readonly __brand: 'PatientId' };
type OrderId = string & { readonly __brand: 'OrderId' };
```

**Benefits:**
- **Cannot accidentally mix IDs:** TypeScript prevents passing an OrderId where a PatientId is expected
- **Zero runtime cost:** Branding exists only at compile time
- **Self-documenting:** Function signatures clearly show what type of ID is required

## Domain Model

### Core Entities

The domain model reflects real-world specialty pharmacy operations with rich validation:

#### Patient
- **Unique constraint:** MRN is unique *per clinic*, but multiple patients can share an MRN (different visits)
- **Fuzzy matching:** Name similarity detection prevents duplicate records from typos
- **HIPAA considerations:** PHI is properly isolated and access-controlled

#### Order (Medication Request)
- **Lifecycle tracking:** Status transitions from pending → approved → completed
- **Medication validation:** ICD-10 codes must be valid and appropriately formatted
- **Provider verification:** NPI validation uses Luhn algorithm for authenticity

#### Care Plan (AI-Generated)
- **Structured format:** 4-section format ensures completeness
- **Clinical accuracy:** Generated by Claude AI with medical knowledge
- **Audit trail:** Creation timestamp and version tracking

### Business Rules Engine

The system implements complex business logic through a validation pipeline:

1. **NPI Validation** - Luhn checksum algorithm (CMS standard)
2. **ICD-10 Validation** - Format checking with decimal point requirement
3. **Duplicate Detection** - Multi-layered fuzzy matching (name, MRN, medication)
4. **Provider Conflict Detection** - Same NPI with different names triggers warning
5. **Order Deduplication** - Same patient + medication within timeframe

**What makes this special:** Rather than blocking operations, the system uses a **warning-based approach** that allows clinicians to make informed decisions. Real-world healthcare often requires flexibility.

## Data Flow Patterns

### Patient Creation Flow

```
User Input
    ↓
Form Validation (Zod schema)
    ↓
API: /api/patients/validate
    ↓
Validation Service
    ├─ NPI check
    ├─ ICD-10 format check
    ├─ Duplicate detection
    └─ Provider conflict check
    ↓
Warnings returned (if any)
    ↓
User reviews warnings
    ↓
API: /api/patients (with skipWarnings flag)
    ↓
Patient Service
    ↓
Atomic Prisma Transaction
    ├─ Create Patient
    ├─ Create Order
    ├─ Link Provider
    └─ Commit
    ↓
Success Response
```

**Key insight:** The two-step validation ensures users always see warnings *before* database changes occur. This prevents "surprise" duplicates after the fact.

### AI Care Plan Generation Flow

```
Patient + Order Data
    ↓
Care Plan Service
    ↓
Build Prompt with Medical Context
    ├─ Patient demographics
    ├─ Medical history
    ├─ Diagnosis codes
    ├─ Medication details
    └─ Clinical notes
    ↓
Claude API (Haiku 4.5)
    ├─ Model: claude-haiku-4-5-20251001
    ├─ Temperature: 0.3 (consistent medical advice)
    └─ Max tokens: 3500
    ↓
Parse Markdown Response
    ├─ Extract sections
    ├─ Validate structure
    └─ Store as formatted markdown
    ↓
Store in Database
    ↓
Return Care Plan
```

**Why Claude Haiku:** Balances speed (~3-5s generation), cost (~$0.02 per plan), and quality (medical accuracy). Faster than Sonnet, more capable than older models.

## Performance Considerations

### Database Query Optimization

1. **Eager loading with `include`:** Prevents N+1 query problems
2. **Indexed fields:** MRN, NPI, and patient name are indexed for fast lookups
3. **Pagination:** Large result sets use cursor-based pagination
4. **Connection pooling:** Prisma manages connection pool efficiently

### AI Generation Strategy

1. **Streaming disabled for consistency:** Care plans are generated in full to ensure complete medical advice
2. **Retry logic:** Handles transient API failures with exponential backoff
3. **Caching consideration:** Care plans are stored, not regenerated on each view
4. **Model selection:** Haiku provides 5-10x faster generation than Opus at similar quality for this use case

### Frontend Optimization

1. **React Query caching:** API responses cached client-side for instant navigation
2. **Server-side rendering:** Initial page load includes data (SEO, performance)
3. **Optimistic updates:** UI responds immediately while requests process in background
4. **Incremental Static Regeneration:** Static pages revalidate every 60 seconds

## Security & Compliance

### Data Protection

- **Input sanitization:** All user inputs validated with Zod before reaching database
- **SQL injection prevention:** Prisma's parameterized queries prevent SQL injection
- **XSS protection:** React automatically escapes rendered content
- **CSRF protection:** Next.js provides built-in CSRF protection for forms

### HIPAA Considerations

While this is a demonstration application, it follows HIPAA-aligned practices:

- **Minimal PHI exposure:** Only necessary fields included in API responses
- **Audit logging:** Database tracks creation/update timestamps
- **Access control ready:** Architecture supports role-based access control (RBAC)
- **Secure transmission:** Production deployment should use HTTPS only

## Testing Strategy

### Unit Tests
- **Domain logic:** Pure functions tested in isolation
- **Validation rules:** Zod schemas tested with valid/invalid inputs
- **Service methods:** Tested with mocked dependencies

### Integration Tests
- **API endpoints:** Test full request/response cycle with test database
- **Database operations:** Verify transaction atomicity and rollback behavior
- **AI integration:** Mock Claude API responses for consistent testing

### End-to-End Tests
- **Playwright tests:** Simulate real user workflows
- **Critical paths:** Patient creation, care plan generation, duplicate detection
- **Cross-browser:** Tested on Chrome, Firefox, Safari

## Scalability Path

### Current Architecture Supports

1. **Horizontal scaling:** Stateless API handlers can scale across multiple instances
2. **Database scaling:** Prisma supports read replicas and connection pooling
3. **Caching layer:** Redis can be added for frequently accessed data
4. **CDN integration:** Static assets served from edge locations

### Future Enhancements

1. **Event-driven architecture:** Add event bus for audit logs, notifications
2. **Microservices migration:** Extract AI service, validation service as separate services
3. **GraphQL API:** Add GraphQL layer for more flexible client queries
4. **Real-time updates:** WebSocket support for live care plan generation status

## Why This Architecture Excels

1. **Type Safety:** TypeScript catches errors at compile time, not runtime
2. **Testability:** Dependency injection and pure functions make testing straightforward
3. **Maintainability:** Clear boundaries and single-responsibility principle
4. **Extensibility:** New features integrate cleanly without refactoring existing code
5. **Production-Ready:** Error handling, validation, and security built in from the start
6. **Developer Experience:** Clear patterns make onboarding new developers faster
7. **AI Integration:** First-class support for LLM-powered features with proper error handling

This architecture demonstrates modern best practices for building healthcare applications that are both powerful and maintainable.
